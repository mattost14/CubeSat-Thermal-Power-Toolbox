function [pwr, flag] = computePower(param)
%COMPUTEPOWER computed the power generated by all solar panels defined in
%the Model Tab
% This version does not support: shadowing between faces and panels
    
% Get attitude 
[XplusFaceVector_LVLH, YplusFaceVector_LVLH, ZplusFaceVector_LVLH] = getCubeSatAttitude(param);
param.attitude.XplusFaceVector_LVLH = XplusFaceVector_LVLH; 
param.attitude.YplusFaceVector_LVLH = YplusFaceVector_LVLH;
param.attitude.ZplusFaceVector_LVLH = ZplusFaceVector_LVLH;

% Compute solar light
solarLight = computeFaceSolarLight(param);

% Get parameters from orbit propagation
time_Epoch = param.orb.prop.time_Epoch;
sunMagnitude = param.orb.prop.sunMagnitude;

%% ## Shadow analysis ##

if(param.computePwrWithShadowFlag)
    try
        shadow = computeShadowFactors(param, solarLight);
        shadow.flag = 1;
    catch ME
        shadow.flag = 0;
    end
else
    shadow.flag = 0;
end


%% ## Generate power consumption profile ##
pwrDissipationProfileList = param.pwrDissipationProfile;
dayPwr = param.pwrDissipationDaySimpleModel;      % W
nightPwr = param.pwrDissipationNightSimpleModel;    % W

switch pwrDissipationProfileList
    case "Constant"
        powerDissipationProfile.totalPwr = dayPwr .* ones(length(time_Epoch),1);
    case "Day/Night"
        powerDissipationProfile.totalPwr = dayPwr .* sunMagnitude + nightPwr .* (1-sunMagnitude);
end

%% ## Compute View Factor ##

% function that return angle between two vectors in degrees
calculateAngleBetweenVectors = @(u,v) acosd(max(min(dot(u,v)/(norm(u)*norm(v)),1),-1));

% Angle between Face Normal with Nadir Vector
nadirVector_LVLH = [0 0 1];
Xface2NadirAngle_deg = ones(length(time_Epoch),1)*calculateAngleBetweenVectors(XplusFaceVector_LVLH, nadirVector_LVLH);
Yface2NadirAngle_deg = ones(length(time_Epoch),1)*calculateAngleBetweenVectors(YplusFaceVector_LVLH, nadirVector_LVLH);
Zface2NadirAngle_deg = ones(length(time_Epoch),1)*calculateAngleBetweenVectors(ZplusFaceVector_LVLH ,nadirVector_LVLH);

R = param.orb.prop.centralBodyRadius;   % m
H = param.orb.prop.altitude*1e3 + R;    % m

viewFactor(:,1) = calculateViewFactor(Xface2NadirAngle_deg, H, R);
viewFactor(:,2) = calculateViewFactor(180-Xface2NadirAngle_deg, H, R);
viewFactor(:,3) = calculateViewFactor(Yface2NadirAngle_deg, H, R);
viewFactor(:,4) = calculateViewFactor(180-Yface2NadirAngle_deg, H, R);
viewFactor(:,5) = calculateViewFactor(Zface2NadirAngle_deg, H, R);
viewFactor(:,6) = calculateViewFactor(180-Zface2NadirAngle_deg, H, R);


%% ## Compute power generation ##

facesMaterial = param.facesMaterial;
deployable = param.deployable;
faceText = ["X+","X-","Y+","Y-","Z+","Z-"];
solarFlux = param.orb.solarFlux;
facesArea = param.facesArea;
solarCellEff = param.solarCellEff;
effectiveAreaRatio = param.effectiveAreaRatio;
generatedTotalPower = zeros(length(time_Epoch),1);
electricalEfficiency = zeros(length(time_Epoch),1);
energyDrawnFromBat_Wh = zeros(length(time_Epoch),1);
energyDebtToChargeBat = 0;

for i=1:length(time_Epoch)  

    % Compute last time sample duration
    sampleTime = 0;
    if(i~=1)
        sampleTime = time_Epoch(i) - time_Epoch(i-1);
    end


    if(sunMagnitude(i)) % if sat is under sun light       
        % Calculated maximum power generated by the solar cells
        generatedPwr = 0;
        for n=1:6
            
            % ##### Power from Body-Fixed Solar Panels #####
            if(facesMaterial(n)=="Solar Panel")
                if(param.computePwrWithShadowFlag && shadow.flag) % Check if user wants to consider shadow losses
                    iluminatedAreaRatio = 1 - shadow.shadowFaceAreaRatio(i,n);
                    generatedPwr = generatedPwr + solarLight(i,n).(1) * solarFlux * facesArea(n) * solarCellEff(n) * effectiveAreaRatio(n) * iluminatedAreaRatio;
                else
                    generatedPwr = generatedPwr + solarLight(i,n).(1) * solarFlux * facesArea(n) * solarCellEff(n) * effectiveAreaRatio(n);
                end
            end

            % ##### Power from fixed deployed Solar Panels #####
            if(deployable.type(n)== "Fixed")
                % Check the hinge face
                hingeFace = extractAfter(deployable.hinge(n), " | ");
                hingeFace = char(hingeFace);
                % Check if the panel is flipped
                flipFlag = deployable.flipFixedPanel(n);
                if(flipFlag==1 && hingeFace(2) == '+')
                    hingeFace(2) = '-';
                elseif(flipFlag==1 && hingeFace(2) == '-')
                    hingeFace(2) = '+';
                end
                idx = find(faceText==hingeFace);
                % Check how many panels
                numPanels = str2num(extractBefore(deployable.size(n), "P"));

                if(param.computePwrWithShadowFlag && shadow.flag) % Check if user wants to consider shadow losses
                    iluminatedAreaRatio = 1 - shadow.shadowPanelAreaRatio(i,n);
                    generatedPwr = generatedPwr + solarLight(i,idx).(1) * solarFlux * numPanels * facesArea(n) * deployable.solarCellEff(n) * deployable.effectiveAreaRatio(n) * iluminatedAreaRatio;
                else
                    generatedPwr = generatedPwr + solarLight(i,idx).(1) * solarFlux * numPanels * facesArea(n) * deployable.solarCellEff(n) * deployable.effectiveAreaRatio(n);
                end
            end

            % ##### Power from sun-tracking Solar Panels #####
            if(deployable.type(n)== "Tracking")
                % The solarLight table stores the cosd of the angle between
                % the sun vector and the surface normal vector
                % In tracking, where the axis of rotation is the normal
                % vector, we just need the cossine of the complement angle
                % cos(pi/2 - theta) = cos(pi/2)cos(theta) +
                % sin(pi/2)sin(theta) = sin(theta)
                theta = acosd(solarLight(i,n).(1));
                % Check how many panels
                numPanels = str2num(extractBefore(deployable.size(n), "P"));

                if(param.computePwrWithShadowFlag && shadow.flag) % Check if user wants to consider shadow losses
                    iluminatedAreaRatio = 1 - shadow.shadowPanelAreaRatio(i,n);
                    generatedPwr = generatedPwr + sind(theta) * solarFlux * numPanels * facesArea(n) * deployable.solarCellEff(n) * deployable.effectiveAreaRatio(n) * iluminatedAreaRatio;
                else
                    generatedPwr = generatedPwr + sind(theta) * solarFlux * numPanels * facesArea(n) * deployable.solarCellEff(n) * deployable.effectiveAreaRatio(n);
                end
            end

        end

        % ###### Battery Charging ######
        % Check power generation surplus (Generated Pwr - Consumed Pwr)
        powerLeftToChargeBat = generatedPwr - powerDissipationProfile.totalPwr(i);
        
        % Check the need to charge battery
        if(energyDebtToChargeBat>0 || powerLeftToChargeBat<0) % Battery is not full or generatedPwr is not enought to sustain power consumption
            electricalEfficiency(i)=1;         
            energyToChargeBat = powerLeftToChargeBat * sampleTime;
            energyDebtToChargeBat=energyDebtToChargeBat-energyToChargeBat;
            if(energyDebtToChargeBat<=0) % Battery is full
                energyDebtToChargeBat=0;
            end
        else
            % battery is full, so electrical efficiency is driven by how
            % much power the sat is consuming
            electricalEfficiency(i)=powerDissipationProfile.totalPwr(i)/generatedPwr;
        end

        generatedTotalPower(i) = generatedPwr;
    
    else
        % Sat is under eclipse, so all power is drawn from battery
        energyDebtToChargeBat = energyDebtToChargeBat + powerDissipationProfile.totalPwr(i) .* sampleTime;
    end
    energyDrawnFromBat_Wh(i) = energyDebtToChargeBat/(3600); %Ws->Wh 
end

%% Return results
flag = 1;
pwr.generatedTotalPower = generatedTotalPower;
pwr.time_Epoch = time_Epoch;
pwr.energyDrawnFromBat_Wh = energyDrawnFromBat_Wh;
pwr.electricalEfficiency = electricalEfficiency;
pwr.powerDissipationProfile = powerDissipationProfile;
pwr.solarLight = solarLight;
pwr.XplusFaceVector_LVLH = XplusFaceVector_LVLH;
pwr.YplusFaceVector_LVLH = YplusFaceVector_LVLH;
pwr.ZplusFaceVector_LVLH = ZplusFaceVector_LVLH;
pwr.viewFactor = viewFactor;
pwr.shadow = shadow;
end

function F = calculateViewFactor(beta_deg, H, R)
    % ref:
    % http://imartinez.etsiae.upm.es/~isidoro/tc3/Radiation%20View%20factors.pdf
    % (page 10)
    
    F = zeros(length(beta_deg),1);
    for i=1:length(beta_deg)
        h = H(i)/R;
        if(beta_deg(i)<=90)
            if(abs(beta_deg(i)) <= acosd(1/h)) % plane not cutting the sphere
                F(i) = cosd(beta_deg(i))/h^2;
            else
                x = sqrt(h^2-1);
                y = -x * cotd(beta_deg(i));
                F(i) = (1/(pi*h^2)) * (cosd(beta_deg(i))*acos(y) - x*sind(beta_deg(i))*sqrt(1-y^2)) + (1/pi)*atan(sind(beta_deg(i))*sqrt(1-y^2)/x);
            end
        end
    end
end


