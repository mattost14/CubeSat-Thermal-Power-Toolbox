function [pwr, flag] = computePower(param)
%COMPUTEPOWER computed the power generated by all solar panels defined in
%the Thermal Tab
% This version does not support: shadowing between faces and panels
    
% Get attitude settings
nadirFace = param.attitude.nadirFace;
ramFace = param.attitude.ramFace;

% Define sat attitude in the LVLH based on the attitude settings
nadirFaceId=char(nadirFace); 
switch nadirFaceId(1) 
    case "X"
        if(nadirFaceId(2)=="+")
            XplusFaceVector_LVLH = [0; 0; 1];
        else
            XplusFaceVector_LVLH = [0; 0; -1];
        end
    case "Y"
        if(nadirFaceId(2)=="+")
            YplusFaceVector_LVLH = [0; 0; 1];
        else
            YplusFaceVector_LVLH = [0; 0; -1];
        end
    case "Z"
        if(nadirFaceId(2)=="+")
            ZplusFaceVector_LVLH = [0; 0; 1];
        else
            ZplusFaceVector_LVLH = [0; 0; -1];
        end
end

ramFaceId=char(ramFace); 
switch ramFaceId(1) 
    case "X"
        if(ramFaceId(2)=="+")
            XplusFaceVector_LVLH = [1; 0; 0];
        else
            XplusFaceVector_LVLH = [-1; 0; 0];
        end
    case "Y"
        if(ramFaceId(2)=="+")
            YplusFaceVector_LVLH = [1; 0; 0];
        else
            YplusFaceVector_LVLH = [-1; 0; 0];
        end
    case "Z"
        if(ramFaceId(2)=="+")
            ZplusFaceVector_LVLH = [1; 0; 0];
        else
            ZplusFaceVector_LVLH = [-1; 0; 0];
        end
end

listOfFaces = ["X", "Y", "Z"];
filterCondition = find((listOfFaces~=nadirFaceId(1)) & (listOfFaces~=ramFaceId(1)));
lastFace = listOfFaces(filterCondition);
switch lastFace
    case "X"
            XplusFaceVector_LVLH = cross(YplusFaceVector_LVLH, ZplusFaceVector_LVLH);
    case "Y"
            YplusFaceVector_LVLH = cross(ZplusFaceVector_LVLH, XplusFaceVector_LVLH);
    case "Z"
            ZplusFaceVector_LVLH = cross(XplusFaceVector_LVLH, YplusFaceVector_LVLH);
end

% Get orbit propagation position and velocity in the inertial frame
r_I = param.orb.prop.r_I;
v_I = param.orb.prop.v_I;
time_Epoch = param.orb.prop.time_Epoch;
sampleTime = time_Epoch(2) - time_Epoch(1);

% Get sun lightining
sun_I = param.orb.prop.Sun_I;
sunMagnitude = param.orb.prop.sunMagnitude;

% function that return angle between two vectors in degrees
calculateAngleBetweenVectors = @(u,v) acosd(max(min(dot(u,v)/(norm(u)*norm(v)),1),-1));

% Compute sun lightining at each face
sunMagnitudeXfaces = zeros(length(time_Epoch),1);
sunMagnitudeYfaces = zeros(length(time_Epoch),1);
sunMagnitudeZfaces = zeros(length(time_Epoch),1);
for i=1:length(time_Epoch)
    if(sunMagnitude(i))
        % LVLH unit vectors 
        % (z: Nadir, 
        % y: opposite direction of orbit angular momentum, 
        % x: completes right-handed frame ~ velocity direction)
        r = r_I(i,:)'; v = v_I(i,:)'; 
        z_L2I = -r/norm(r);   % Unit vector z
        h_I = cross(r, v);    % Angular momentum 
        y_L2I = -h_I/norm(h_I);             % Unit vector y
        x_L2I = cross(y_L2I, z_L2I);        % Unit vector x
        % Rotation matrix from Inertial Frame to LVLH frame
        A_I2L = [x_L2I'; y_L2I'; z_L2I'];
    
        % Compute sun unit vector at LVLH frame
        sun = sun_I(i,:)';
        sun_L = A_I2L * sun;
        sun_L = sun_L / norm(sun_L);
    
        % Compute sun angles at each face
        angle_faceXNormal_Sun = calculateAngleBetweenVectors(sun_L,XplusFaceVector_LVLH);
        angle_faceYNormal_Sun = calculateAngleBetweenVectors(sun_L,YplusFaceVector_LVLH);
        angle_faceZNormal_Sun = calculateAngleBetweenVectors(sun_L,ZplusFaceVector_LVLH);
        
        sunMagnitudeXfaces(i) = cosd(angle_faceXNormal_Sun);
        sunMagnitudeYfaces(i) = cosd(angle_faceYNormal_Sun);
        sunMagnitudeZfaces(i) = cosd(angle_faceZNormal_Sun); 
    end
end

solarLight = [time_Epoch, ...
              max(sunMagnitudeXfaces,0),...
              max(-sunMagnitudeXfaces,0),...
              max(sunMagnitudeYfaces,0),...
              max(-sunMagnitudeYfaces,0),...
              max(sunMagnitudeZfaces,0),...
              max(-sunMagnitudeZfaces,0),...
              sunMagnitude];
          
solarLight = array2table(solarLight);
solarLight.Properties.VariableNames = {'time','x_plus_magnitude','x_minus_magnitude','y_plus_magnitude','y_minus_magnitude', 'z_plus_magnitude', 'z_minus_magnitude','magnitude'};
solarLight.time = seconds(solarLight.time);
solarLight = table2timetable(solarLight);

%% Generate power consumption profile
pwrDissipationProfileList = param.pwrDissipationProfile;
dayPwr = param.pwrDissipationDaySimpleModel;      % W
nightPwr = param.pwrDissipationNightSimpleModel;    % W

switch pwrDissipationProfileList
    case "Constant"
        powerDissipationProfile.totalPwr = dayPwr .* ones(length(time_Epoch),1);
    case "Day/Night"
        powerDissipationProfile.totalPwr = dayPwr .* sunMagnitude + nightPwr .* (1-sunMagnitude);
end

%% Compute View Factor

% Angle between Face Normal with Nadir Vector
nadirVector_LVLH = [0 0 1];
Xface2NadirAngle_deg = ones(length(time_Epoch),1)*calculateAngleBetweenVectors(XplusFaceVector_LVLH, nadirVector_LVLH);
Yface2NadirAngle_deg = ones(length(time_Epoch),1)*calculateAngleBetweenVectors(YplusFaceVector_LVLH, nadirVector_LVLH);
Zface2NadirAngle_deg = ones(length(time_Epoch),1)*calculateAngleBetweenVectors(ZplusFaceVector_LVLH ,nadirVector_LVLH);

R = param.orb.prop.centralBodyRadius;   % m
H = param.orb.prop.altitude*1e3 + R;    % m

viewFactor(:,1) = calculateViewFactor(Xface2NadirAngle_deg, H, R);
viewFactor(:,2) = calculateViewFactor(180-Xface2NadirAngle_deg, H, R);
viewFactor(:,3) = calculateViewFactor(Yface2NadirAngle_deg, H, R);
viewFactor(:,4) = calculateViewFactor(180-Yface2NadirAngle_deg, H, R);
viewFactor(:,5) = calculateViewFactor(Zface2NadirAngle_deg, H, R);
viewFactor(:,6) = calculateViewFactor(180-Zface2NadirAngle_deg, H, R);


%% Compute power generation 
facesMaterial = param.facesMaterial;
deployable = param.deployable;
faceText = ["X+","X-","Y+","Y-","Z+","Z-"];
solarFlux = param.orb.solarFlux;
facesArea = param.facesArea;
solarCellEff = param.solarCellEff;
effectiveAreaRatio = param.effectiveAreaRatio;
generatedTotalPower = zeros(length(time_Epoch),1);
electricalEfficiency = zeros(length(time_Epoch),1);
energyDrawnFromBat_Wh = zeros(length(time_Epoch),1);
energyDebtToChargeBat = 0;
for i=1:length(time_Epoch)  
    if(sunMagnitude(i)) % if sat is under sun light       
        % Calculated maximum power generated by the solar cells
        generatedPwr = 0;
        for n=1:6
            
            % ##### Power from Body-Fixed Solar Panels #####
            if(facesMaterial(n)=="Solar Panel")
                generatedPwr = generatedPwr + solarLight(i,n).(1) * solarFlux * facesArea(n) * solarCellEff(n) * effectiveAreaRatio(n);
            end

            % ##### Power from fixed deployed Solar Panels #####
            if(deployable.type(n)== "Fixed")
                % Check the hinge face
                hingeFace = extractAfter(deployable.hinge(n), " | ");
                hingeFace = char(hingeFace);
                % Check if the panel is flipped
                flipFlag = deployable.flipFixedPanel(n);
                if(flipFlag==1 && hingeFace(2) == '+')
                    hingeFace(2) = '-';
                elseif(flipFlag==1 && hingeFace(2) == '-')
                    hingeFace(2) = '+';
                end
                idx = find(faceText==hingeFace);
                % Check how many panels
                numPanels = str2num(extractBefore(deployable.size(n), "P"));
                generatedPwr = generatedPwr + solarLight(i,idx).(1) * solarFlux * numPanels * facesArea(n) * deployable.solarCellEff(n) * deployable.effectiveAreaRatio(n);
            end

            % ##### Power from sun-tracking Solar Panels #####
            if(deployable.type(n)== "Tracking")
                % The solarLight table stores the cosd of the angle between
                % the sun vector and the surface normal vector
                % In tracking, where the axis of rotation is the normal
                % vector, we just need the cossine of the complement angle
                % cos(pi/2 - theta) = cos(pi/2)cos(theta) +
                % sin(pi/2)sin(theta) = sin(theta)
                theta = acosd(solarLight(i,n).(1));
                % Check how many panels
                numPanels = str2num(extractBefore(deployable.size(n), "P"));
                generatedPwr = generatedPwr + sind(theta) * solarFlux * numPanels * facesArea(n) * deployable.solarCellEff(n) * deployable.effectiveAreaRatio(n);
            end

        end

        % ###### Battery Charging ######
        % Check power generation surplus (Generated Pwr - Consumed Pwr)
        powerLeftToChargeBat = generatedPwr - powerDissipationProfile.totalPwr(i);
        
        % Check the need to charge battery
        if(energyDebtToChargeBat>0 || powerLeftToChargeBat<0) % Battery is not full or generatedPwr is not enought to sustain power consumption
            electricalEfficiency(i)=1;         
            energyToChargeBat = powerLeftToChargeBat * sampleTime;
            energyDebtToChargeBat=energyDebtToChargeBat-energyToChargeBat;
            if(energyDebtToChargeBat<=0) % Battery is full
                energyDebtToChargeBat=0;
            end
        else
            % battery is full, so electrical efficiency is driven by how
            % much power the sat is consuming
            electricalEfficiency(i)=powerDissipationProfile.totalPwr(i)/generatedPwr;
        end

        generatedTotalPower(i) = generatedPwr;
    
    else
        % Sat is under eclipse, so all power is drawn from battery
        energyDebtToChargeBat = energyDebtToChargeBat + powerDissipationProfile.totalPwr(i) .* sampleTime;
    end
    energyDrawnFromBat_Wh(i) = energyDebtToChargeBat/(3600); %Ws->Wh 
end

%% Return results
flag = 1;
pwr.generatedTotalPower = generatedTotalPower;
pwr.time_Epoch = time_Epoch;
pwr.energyDrawnFromBat_Wh = energyDrawnFromBat_Wh;
pwr.electricalEfficiency = electricalEfficiency;
pwr.powerDissipationProfile = powerDissipationProfile;
pwr.solarLight = solarLight;
pwr.XplusFaceVector_LVLH = XplusFaceVector_LVLH;
pwr.YplusFaceVector_LVLH = YplusFaceVector_LVLH;
pwr.ZplusFaceVector_LVLH = ZplusFaceVector_LVLH;
pwr.viewFactor = viewFactor;
end

function F = calculateViewFactor(beta_deg, H, R)
    % ref:
    % http://imartinez.etsiae.upm.es/~isidoro/tc3/Radiation%20View%20factors.pdf
    % (page 10)
    
    F = zeros(length(beta_deg),1);
    for i=1:length(beta_deg)
        h = H(i)/R;
        if(beta_deg(i)<=90)
            if(abs(beta_deg(i)) <= acosd(1/h)) % plane not cutting the sphere
                F(i) = cosd(beta_deg(i))/h^2;
            else
                x = sqrt(h^2-1);
                y = -x * cotd(beta_deg(i));
                F(i) = (1/(pi*h^2)) * (cosd(beta_deg(i))*acos(y) - x*sind(beta_deg(i))*sqrt(1-y^2)) + (1/pi)*atan(sind(beta_deg(i))*sqrt(1-y^2)/x);
            end
        end
    end
end


